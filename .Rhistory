return(hv_list)
}
hypervolume_overlap <- function(list_combi, nb_combi, hv_list, species_list_hv_selected){
combi_df <- data.frame(matrix(ncol = nb_combi, nrow = 0))
for ( i in 1:length(list_combi)){
vect <- list_combi[[i]]
length(vect) <- nb_combi+1
combi_df <- rbind(combi_df, vect)
}
combi_df[is.na(combi_df)] <- "None"
for (i in 1:length(combi_df[,1])){
ind <- c()
hv_list_test <- new("HypervolumeList")
for (j in 1:length(species_list_hv_selected)){
for (q in 1:length(combi_df[1,])){
if (combi_df[[q]][i] == hv_list[[j]]@Name){
ind <- c(ind, j)
}
}
}
hv_list_test <-  hv_list[[ind]]
intersection <- HV_intersection(hv_list_test)
combi_df[[nb_combi+1]][i] <- intersection@Volume
}
#rescale
combi_df[[nb_combi+1]] <- as.numeric(combi_df[[nb_combi+1]])
rescaled_combi_df <- rescale.many(combi_df, nb_combi+1)
#species_abiotics_df_sub <- rescaled_abiotics_save %>% filter(
#species %in% c(species_list_hv_selected)
#)
#rescaled_abiotics_df <- rescale.many(species_abiotics_df_sub, c(2:11))
return(rescaled_combi_df)
}
Shiny_HV_overlap <- function(species_list_hv_selected,nb_combi, selected_abiotics, rescaled_combi_df, species_abiotics_df){
shinyApp(
ui = fluidPage(
titlePanel("Species compatibility"),
sidebarLayout(
sidebarPanel(
selectInput(inputId = "central_species",
label = "Choose a central species:",
choices = c("None", species_list_hv_selected)),
selectInput(inputId = "nb_species",
label = "Choose a number of species:",
choices = 2:as.numeric(nb_combi)),
selectInput(inputId = "nb_combi_display",
label = "Choose the number of best combinations to display:",
choices = 5:50),
selectInput(inputId = "Factor",
label = "Choose a factor:",
choices = selected_abiotics),
checkboxGroupInput(inputId = "species_show",
label = "Chose species to show:",
choiceNames = species_list_hv_selected,
choiceValues = species_list_hv_selected)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: HTML table with requested number of observations ----
plotOutput("plot1", width = "100%", height = 600),
plotOutput("plot2", width = "100%", height = 400)
)
)
),
#### set server #####
server = function(input, output) {
selected_species <- species_list_hv_selected
#static background map
output$plot1 <- renderPlot({
if (input$central_species == "None"){
combi_df_sp <- data.frame(matrix(ncol = as.numeric(input$nb_species), nrow = 0))
for (i in 1:length(rescaled_combi_df[,1])){
n <- rowSums(rescaled_combi_df == "None")
if ((nb_combi - n[i]) == as.numeric(input$nb_species)){
vect <- rescaled_combi_df[i,]
combi_df_sp <- rbind(combi_df_sp, vect)
}
}
best_combi <- combi_df_sp %>% arrange(desc(as.numeric(combi_df_sp[[nb_combi+1]]))) %>% ## on classe par ordre d?croissant
slice(1:input$nb_combi_display) ## on s?lectionne les 5 premi?res lignes (les plus hautes)
}
else{
row_sub = apply(rescaled_combi_df, 1, function(row) all(row != input$central_species ))
combi_df_sub <- rescaled_combi_df[!row_sub,]
combi_df_central_sp <- data.frame(matrix(ncol = as.numeric(input$nb_species), nrow = 0))
for (i in 1:length(combi_df_sub[,1])){
n <- rowSums(combi_df_sub == "None")
if ((nb_combi - n[i]) == as.numeric(input$nb_species)){
vect <- combi_df_sub[i,]
combi_df_central_sp <- rbind(combi_df_central_sp, vect)
}
}
best_combi <- combi_df_central_sp %>% arrange(desc(as.numeric(combi_df_central_sp[[nb_combi+1]]))) %>% ## on classe par ordre d?croissant
slice(1:input$nb_combi_display) ## on s?lectionne les 5 premi?res lignes (les plus hautes)
}
names_list <- c()
for (i in 1:length(best_combi[,1])){
combi_name <- c()
for (j in 1:(length(best_combi[1,])-1)){
if (best_combi[[j]][i] != "None"){
combi_name <- paste(combi_name,  best_combi[[j]][i], sep = "\n")
}
}
names_list <- c(names_list, combi_name)
}
best_combi<- cbind(best_combi, names_list)
colnames(best_combi)[nb_combi+1] <- c("Intersection_volume")
colnames(best_combi)[nb_combi+2] <- c("names_list")
ggplot(data = best_combi, aes(x = reorder(names_list,-Intersection_volume) , y = Intersection_volume)) +
geom_bar(stat="identity")
})
output$plot2 <- renderPlot({
species_abiotics_df_sub <- species_abiotics_df %>% filter(
species %in% input$species_show
)
ggplot(species_abiotics_df_sub,
aes(x = species_abiotics_df_sub[,input$Factor],
fill = species)) +
geom_density(alpha = 0.4)
})
}
)
}
#___________________________
rescaled_combi_df <- hypervolume_overlap(hv_list)
View(hypervolume_overlap)
install.packages("FishNmix2")
install.packages("FishNmix2")
library(FishNmix2)
View(hypervolume_overlap)
library(FishNmix2)
View(hypervolume_overlap)
remove.packages("FishNmix2")
library(FishNmix2)
View(hypervolume_overlap)
View(hypervolume_overlap)
View(FishNmix2::hypervolume_overlap)
View(FishNmix2::hypervolume_overlap)
View(FishNmix2::hypervolume_overlap)
rescaled_combi_df <- FishNmix2::hypervolume_overlap(hv_list)
globalenv()
memory.limit()
gbif_download <- function(species_list, gbif_user, gbif_pwd, mail){
species_gbifid <- get_gbifid_(species_list) #gives a list of lists with the 3 first results in gbif for each species
gbif_taxon_keys<-c()
for (i in 1:length(species_gbifid)) {
if (species_gbifid[[c(i,5,1)]] == "EXACT"){ #for each species (i) check "matchtype" (5st list) to make sure that the wanted species corresponds to gbif first result (1)
gbif_taxon_keys <- c(gbif_taxon_keys, species_gbifid[[c(i,1,1)]])  #add "usagekey" (1st list) to the list
}
else { #if the matchtype is not exact, suggest to change species name for gbif 1st result
stop(paste0("!!! Warning !!! Species '",species_list[i],"' not found, please try again with : ",species_gbifid[[c(i,2)]])) #if the species does not exactly match with gbif 1st result, the algorithm suggest to try first result's "scientificname" (2nd list)
}
}
###Download the data from GBIF,enter username/password/email. Only keeping data with coordinates (The data is loaded on gbif and ready to download)
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV",user, pwd, email)
return(data)
}
data <- gbif_download("Acipenser Sturio")
species_list <- c("Acipenser sturio")
species_gbifid <- get_gbifid_(species_list) #gives a list of lists with the 3 first results in gbif for each species
library(taxize)
library(rgbif)
species_gbifid <- get_gbifid_(species_list) #gives a list of lists with the 3 first results in gbif for each species
gbif_taxon_keys<-c()
for (i in 1:length(species_gbifid)) {
if (species_gbifid[[c(i,5,1)]] == "EXACT"){ #for each species (i) check "matchtype" (5st list) to make sure that the wanted species corresponds to gbif first result (1)
gbif_taxon_keys <- c(gbif_taxon_keys, species_gbifid[[c(i,1,1)]])  #add "usagekey" (1st list) to the list
}
else { #if the matchtype is not exact, suggest to change species name for gbif 1st result
stop(paste0("!!! Warning !!! Species '",species_list[i],"' not found, please try again with : ",species_gbifid[[c(i,2)]])) #if the species does not exactly match with gbif 1st result, the algorithm suggest to try first result's "scientificname" (2nd list)
}
}
###Download the data from GBIF,enter username/password/email. Only keeping data with coordinates (The data is loaded on gbif and ready to download)
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV",user, pwd, email)
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV","gregoirebutruille", "T&mbetta1", "gregoire.butruille@agrocampus-ouest.fr")
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV",gbif_user ="gregoirebutruille", "T&mbetta1", "gregoire.butruille@agrocampus-ouest.fr")
my_download<-occ_download_get(gbif_data[1],overwrite=TRUE)
print(gbif_citation(gbif_zip_download))
unzip(gbif_zip_download)
print("Downloading datasets from EarthEnv.../n")
print("Downloading datasets from EarthEnv.../n")
print("Downloading datasets from EarthEnv...\n")
for (i in 1:10){
print("Downloading datasets from EarthEnv...\n")
}
cat("Downloading datasets from EarthEnv...\n")
if ("EarthEnv" %in% databases_to_use ){
for (i in 1:10){
cat("Downloading datasets from EarthEnv...\n")
}
download.file("https://data.earthenv.org/streams/hydroclim_average+sum.nc",
paste(getwd(), "hydro_avg.nc", sep="/"), mode = "wb")
download.file("https://data.earthenv.org/streams/soil_maximum.nc",
paste(getwd(), "soil_max.nc", sep="/"), mode = "wb")
download.file("https://data.earthenv.org/streams/elevation.nc",
paste(getwd(), "elevation.nc", sep="/"), mode = "wb")
download.file("https://data.earthenv.org/streams/slope.nc",
paste(getwd(), "slope.nc", sep="/"), mode = "wb")
}
for (i in 1:10){
cat("Downloading datasets from EarthEnv...\n")
}
download.file("https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc.1_10m_srad.zip", paste(getwd(), "srad_zip.zip", sep="/"), mode = "wb")
usethis::use_package("progress")
log(length(1000))
warnings()
log(1000)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
usethis::use_package("ncdf4")
library(FishNmix2)
library(FishNmix2)
dl_min_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_max_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_range_df <- data.frame(matrix(ncol = 3, nrow = 0))
resolution=30
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
minlat = -56maxlat = 60 , minlong =-145, maxlong = 180
minlat = -56
maxlat = 60
minlong =-145
maxlong = 180
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
ymin = -55.75
ymax =59.75
xmin  = -144.75
xmax = 179.75
step = 0.5
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
library(geosphere)
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
ymin = -55.75
ymax =59.75
xmin  = -144.75
xmax = 179.75
step = 0.5
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
View(dl_max_df)
library(FishNmix2)
abiotics_df <- aggregate(earthenv_data[[1]], fact=2*resolution,fun=mean)
cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)
getDoParWorkers()
library(parallel)
library(doParallel)
cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)
getDoParWorkers()
cat("EarthEnv  1/4...\n")
abiotics_df <- aggregate(earthenv_data[[1]], fact=2*resolution,fun=mean)
#create a list of index to use in the loop
months <-c("01","02","03","04","05","06","07","08","09","10","11","12")
bio <-c("12", "13", "14", "15")
#create empty raster brick with 12 layers, with nrow and ncol corresponding to 10 arcmins grid (before spatial filtering)
srad<-brick(nrows=1080,ncol=2160,nl=length(months))
library(raster'
)
)f
rf
$aeztvgtg'okÃ©k'
library(raster)
abiotics_df <- aggregate(earthenv_data[[1]], fact=2*resolution,fun=mean)
dl_min_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_max_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_range_df <- data.frame(matrix(ncol = 3, nrow = 0))
resolution = 30
if (resolution == 30) {
ymin = -10
ymax = 10
xmin = -10
xmax = 10
step = 1
for (y in seq(ymin, ymax, step)) {
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max - min
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
library(geosphere)
if (resolution == 30) {
ymin = -10
ymax = 10
xmin = -10
xmax = 10
step = 1
for (y in seq(ymin, ymax, step)) {
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max - min
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
View(dl_max_df)
if (resolution == 30) {
ymin = -10
ymax = 10
xmin = -10
xmax = 10
step = 0.5
for (y in seq(ymin, ymax, step)) {
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max - min
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
View(dl_max_df)
nb_x <- (xmax-xmin)/step
dl_min_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_max_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_range_df <- data.frame(matrix(ncol = 3, nrow = 0))
View(dl_max_df)
dl_min <- c(1,1,1)
rbind(dl_min_df, rep(dl_min, 5)
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
rbind(dl_min_df, rep(dl_min, 5))
View(dl_min_df)
rbind(dl_min_df, rep(dl_min, 5))
rep(dl_min, 5)
dl_min <- c(1,1,1)
rbind(dl_min_df, rep(dl_min, 5))
rep(dl_min, 5)
dl_min-vect <- rep(dl_min, 5)
dl_min_vect <- rep(dl_min, 5)
dupdf <- df[dl_min_vect,]
dl_min <- as.data.frame(x, y, min)
dl_min <- as.data.frame(dl_min)
View(dl_min)
dl_min_vect <- rep(dl_min, 5)
dl_min_names=c("x", "y", "min")
dl_min <- c(x, y, min)
dl_min_df <- data.frame(dl_min_names, dl_min)
View(dl_min_df)
dl_min_df <- data.frame(y, min)
View(dl_min_df)
dl_min_df[2]
dl_min_vect <- rep(dl_min_df[2], 5)
View(dl_min_vect)
dl_min_vect <- rep(dl_min_df[2,], 5)
View(dl_min_df)
test <- data.frame(x,y)
x <- c(1,1,1,2,2,2,3,3,3)
y <- c(10,10,10,11,11,11,12,12,12)
test <- data.frame(x,y)
View(test)
newtest <- merge(test, dl_min_df, by = c("x", "y"))
newtest <- merge(test, dl_min_df, by =  "y")
View(newtest)
library(FishNmix2)
usethis::use_package("rnaturalearth")
library(FishNmix2)
shinyApp(ui = fluidPage(
titlePanel("Species distribution"),
sidebarLayout(
sidebarPanel(
selectInput(inputId = "Species",
label = "Choose a species:",
choices = species_list)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: HTML table with requested number of observations ----
plotOutput("map", width = "100%", height = 800)
)
)
),
server = function(input, output) {
observeEvent(input$Species,{
data_filtered <- data[data$species==input$Species,]
data_cl_filtered <- data_cl[data_cl$species==input$Species,]
output$map <- renderPlot({
ggplot(data = world)+
geom_sf()+
geom_point(data = data_filtered , aes(x = decimalLongitude, y = decimalLatitude), col = "red")+
geom_point(data = data_cl_filtered , aes(x = decimalLongitude, y = decimalLatitude), col = "blue")
})
})
}
}
return(data_cl)
}
library(FishNmix2)
shinyApp(ui = fluidPage(
titlePanel("Species distribution"),
sidebarLayout(
sidebarPanel(
selectInput(inputId = "Species",
label = "Choose a species:",
choices = species_list)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: HTML table with requested number of observations ----
plotOutput("map", width = "100%", height = 800)
)
)
)
library(FishNmix2)
## Not run:
# construct a hypervolume of points in the unit square [0,1] x [0,1]
data = data.frame(x=runif(100,min=0,max=1), y=runif(100,min=0,max=1))
hv = hypervolume_gaussian(data)
library(hypervolume)
hv = hypervolume_gaussian(data)
# test if (0.5,0.5) and (-1,1) are in - should return TRUE FALSE
hypervolume_inclusion_test(hv, points=data.frame(x=c(0.5,-1),y=c(0.5,-1)))
# test if (0.5,0.5) and (-1,1) are in - should return TRUE FALSE
hypervolume_inclusion_test(hv, points=data.frame(x=0.5,y=c0.5))
# test if (0.5,0.5) and (-1,1) are in - should return TRUE FALSE
hypervolume_inclusion_test(hv, points=data.frame(x=0.5,y=0.5))
res
