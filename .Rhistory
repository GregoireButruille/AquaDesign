#variables_axis <- data.frame(res$co)
axis_names <- c()
for (i in 1:Npc){
axis_names <- c(axis_names, paste0("Axis", i))
}
colnames(rescaled_abiotics) <- c("species", axis_names)
return(rescaled_abiotics)
}
clustering <- function(abiotics_df) {
require(shiny)
method_names <- c("single", "complete", "average")
variable_names <- c("annual_meanT", "T_seasonality", "maxT_WM", "minT_CM", "annual_rangeT", "meanT_DQ", "annual_prec", "prec_WM", "prec_DM", "prec_seasonality", "ph_max", "elevation_avg", "slope_avg", "flow_df_av", "flow_df_mi", "flow_df_ma", "srad", "vapr", "dl_annual_min", "dl_annual_max", "dl_annual_range")
variable_names_display<- c("annual mean Temperature", "Temperature seasonality", "maximum Temperature of the Warmest month","minimum Temperature of the Coldest month","Temperature_annual_range","mean Temperature of the Driest quarter", "annual precipitation", "precipitation of the Wettest month", "precipitation of the Driest month", "precipitations seasonality","maximum ph of the soil", "elevation average", "slope average", "average flow","minimum flow","maximum flow", "solar radiations", "water vapor pressure", "daylength annual min", "daylength annual max", "daylength annual range")
abiotics_df_sub <- abiotics_df[,-(1:2)] #remove x and y columns
shinyApp(
ui <- fluidPage(
titlePanel("Correlations"),
sidebarLayout(
sidebarPanel(
selectInput(inputId = "Method",
label = "Choose method:",
choices = method_names),
numericInput("threshold", "Threshold value :", 0.7, min = 0, max = 1),
verbatimTextOutput("value"),
checkboxGroupInput(inputId = "Factor",
label = "Choose factors to keep:",
choiceNames = variable_names_display,
choiceValues = variable_names),
actionButton(inputId= "submit", label= "submit")
),
# Main panel for displaying outputs ----
mainPanel(
plotOutput("plot1", width = "100%", height = 600)
)
)
),
server <- function(input, output) {
output$plot1 <- renderPlot({
BioClust <- varclus (as.matrix (abiotics_df_sub) , similarity = "spearman", method = input$Method)
plot (BioClust, hang=-1)
abline(h= 1-input$threshold,lwd=2,col="red")
})
observeEvent(input$submit, {
selected_abiotics <<- input$Factor
})
}
)
}
generate_species_hypervolumes <- function(species_list_selected, rescaled_abiotics, nb_axis){
hv_list <- c() #a list to be filled with all the species hypervolumes
for (i in 1:length(species_list_selected)){
data <- subset(rescaled_abiotics, species==species_list_selected[i])[,2:(nb_axis+1)]
print(species_list_selected[i])
print(i)
if (length(data[[1]])>100){  #if there are not enough occurences, an error would appear
hv_species <- hypervolume(data, method='svm')
hv_species@Name <- species_list_selected[[i]]
hv_list<- hypervolume_join(hv_list, hv_species)
}
else {
warning(paste0(species_list_selected[i], "does not have enough values to be studied and has been removed from the list"))
}
}
return(hv_list)
}
hypervolume_overlap <- function(list_combi, nb_combi, hv_list, species_list_hv_selected){
combi_df <- data.frame(matrix(ncol = nb_combi, nrow = 0))
for ( i in 1:length(list_combi)){
vect <- list_combi[[i]]
length(vect) <- nb_combi+1
combi_df <- rbind(combi_df, vect)
}
combi_df[is.na(combi_df)] <- "None"
for (i in 1:length(combi_df[,1])){
ind <- c()
hv_list_test <- new("HypervolumeList")
for (j in 1:length(species_list_hv_selected)){
for (q in 1:length(combi_df[1,])){
if (combi_df[[q]][i] == hv_list[[j]]@Name){
ind <- c(ind, j)
}
}
}
hv_list_test <-  hv_list[[ind]]
intersection <- HV_intersection(hv_list_test)
combi_df[[nb_combi+1]][i] <- intersection@Volume
}
#rescale
combi_df[[nb_combi+1]] <- as.numeric(combi_df[[nb_combi+1]])
rescaled_combi_df <- rescale.many(combi_df, nb_combi+1)
#species_abiotics_df_sub <- rescaled_abiotics_save %>% filter(
#species %in% c(species_list_hv_selected)
#)
#rescaled_abiotics_df <- rescale.many(species_abiotics_df_sub, c(2:11))
return(rescaled_combi_df)
}
Shiny_HV_overlap <- function(species_list_hv_selected,nb_combi, selected_abiotics, rescaled_combi_df, species_abiotics_df){
shinyApp(
ui = fluidPage(
titlePanel("Species compatibility"),
sidebarLayout(
sidebarPanel(
selectInput(inputId = "central_species",
label = "Choose a central species:",
choices = c("None", species_list_hv_selected)),
selectInput(inputId = "nb_species",
label = "Choose a number of species:",
choices = 2:as.numeric(nb_combi)),
selectInput(inputId = "nb_combi_display",
label = "Choose the number of best combinations to display:",
choices = 5:50),
selectInput(inputId = "Factor",
label = "Choose a factor:",
choices = selected_abiotics),
checkboxGroupInput(inputId = "species_show",
label = "Chose species to show:",
choiceNames = species_list_hv_selected,
choiceValues = species_list_hv_selected)
),
# Main panel for displaying outputs ----
mainPanel(
# Output: HTML table with requested number of observations ----
plotOutput("plot1", width = "100%", height = 600),
plotOutput("plot2", width = "100%", height = 400)
)
)
),
#### set server #####
server = function(input, output) {
selected_species <- species_list_hv_selected
#static background map
output$plot1 <- renderPlot({
if (input$central_species == "None"){
combi_df_sp <- data.frame(matrix(ncol = as.numeric(input$nb_species), nrow = 0))
for (i in 1:length(rescaled_combi_df[,1])){
n <- rowSums(rescaled_combi_df == "None")
if ((nb_combi - n[i]) == as.numeric(input$nb_species)){
vect <- rescaled_combi_df[i,]
combi_df_sp <- rbind(combi_df_sp, vect)
}
}
best_combi <- combi_df_sp %>% arrange(desc(as.numeric(combi_df_sp[[nb_combi+1]]))) %>% ## on classe par ordre d?croissant
slice(1:input$nb_combi_display) ## on s?lectionne les 5 premi?res lignes (les plus hautes)
}
else{
row_sub = apply(rescaled_combi_df, 1, function(row) all(row != input$central_species ))
combi_df_sub <- rescaled_combi_df[!row_sub,]
combi_df_central_sp <- data.frame(matrix(ncol = as.numeric(input$nb_species), nrow = 0))
for (i in 1:length(combi_df_sub[,1])){
n <- rowSums(combi_df_sub == "None")
if ((nb_combi - n[i]) == as.numeric(input$nb_species)){
vect <- combi_df_sub[i,]
combi_df_central_sp <- rbind(combi_df_central_sp, vect)
}
}
best_combi <- combi_df_central_sp %>% arrange(desc(as.numeric(combi_df_central_sp[[nb_combi+1]]))) %>% ## on classe par ordre d?croissant
slice(1:input$nb_combi_display) ## on s?lectionne les 5 premi?res lignes (les plus hautes)
}
names_list <- c()
for (i in 1:length(best_combi[,1])){
combi_name <- c()
for (j in 1:(length(best_combi[1,])-1)){
if (best_combi[[j]][i] != "None"){
combi_name <- paste(combi_name,  best_combi[[j]][i], sep = "\n")
}
}
names_list <- c(names_list, combi_name)
}
best_combi<- cbind(best_combi, names_list)
colnames(best_combi)[nb_combi+1] <- c("Intersection_volume")
colnames(best_combi)[nb_combi+2] <- c("names_list")
ggplot(data = best_combi, aes(x = reorder(names_list,-Intersection_volume) , y = Intersection_volume)) +
geom_bar(stat="identity")
})
output$plot2 <- renderPlot({
species_abiotics_df_sub <- species_abiotics_df %>% filter(
species %in% input$species_show
)
ggplot(species_abiotics_df_sub,
aes(x = species_abiotics_df_sub[,input$Factor],
fill = species)) +
geom_density(alpha = 0.4)
})
}
)
}
#___________________________
rescaled_combi_df <- hypervolume_overlap(hv_list)
View(hypervolume_overlap)
install.packages("FishNmix2")
install.packages("FishNmix2")
library(FishNmix2)
View(hypervolume_overlap)
library(FishNmix2)
View(hypervolume_overlap)
remove.packages("FishNmix2")
library(FishNmix2)
View(hypervolume_overlap)
View(hypervolume_overlap)
View(FishNmix2::hypervolume_overlap)
View(FishNmix2::hypervolume_overlap)
View(FishNmix2::hypervolume_overlap)
rescaled_combi_df <- FishNmix2::hypervolume_overlap(hv_list)
globalenv()
memory.limit()
gbif_download <- function(species_list, gbif_user, gbif_pwd, mail){
species_gbifid <- get_gbifid_(species_list) #gives a list of lists with the 3 first results in gbif for each species
gbif_taxon_keys<-c()
for (i in 1:length(species_gbifid)) {
if (species_gbifid[[c(i,5,1)]] == "EXACT"){ #for each species (i) check "matchtype" (5st list) to make sure that the wanted species corresponds to gbif first result (1)
gbif_taxon_keys <- c(gbif_taxon_keys, species_gbifid[[c(i,1,1)]])  #add "usagekey" (1st list) to the list
}
else { #if the matchtype is not exact, suggest to change species name for gbif 1st result
stop(paste0("!!! Warning !!! Species '",species_list[i],"' not found, please try again with : ",species_gbifid[[c(i,2)]])) #if the species does not exactly match with gbif 1st result, the algorithm suggest to try first result's "scientificname" (2nd list)
}
}
###Download the data from GBIF,enter username/password/email. Only keeping data with coordinates (The data is loaded on gbif and ready to download)
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV",user, pwd, email)
return(data)
}
data <- gbif_download("Acipenser Sturio")
species_list <- c("Acipenser sturio")
species_gbifid <- get_gbifid_(species_list) #gives a list of lists with the 3 first results in gbif for each species
library(taxize)
library(rgbif)
species_gbifid <- get_gbifid_(species_list) #gives a list of lists with the 3 first results in gbif for each species
gbif_taxon_keys<-c()
for (i in 1:length(species_gbifid)) {
if (species_gbifid[[c(i,5,1)]] == "EXACT"){ #for each species (i) check "matchtype" (5st list) to make sure that the wanted species corresponds to gbif first result (1)
gbif_taxon_keys <- c(gbif_taxon_keys, species_gbifid[[c(i,1,1)]])  #add "usagekey" (1st list) to the list
}
else { #if the matchtype is not exact, suggest to change species name for gbif 1st result
stop(paste0("!!! Warning !!! Species '",species_list[i],"' not found, please try again with : ",species_gbifid[[c(i,2)]])) #if the species does not exactly match with gbif 1st result, the algorithm suggest to try first result's "scientificname" (2nd list)
}
}
###Download the data from GBIF,enter username/password/email. Only keeping data with coordinates (The data is loaded on gbif and ready to download)
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV",user, pwd, email)
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV","gregoirebutruille", "T&mbetta1", "gregoire.butruille@agrocampus-ouest.fr")
data <- occ_download(pred_in("taxonKey", gbif_taxon_keys), pred("hasCoordinate", TRUE), format = "SIMPLE_CSV",gbif_user ="gregoirebutruille", "T&mbetta1", "gregoire.butruille@agrocampus-ouest.fr")
my_download<-occ_download_get(gbif_data[1],overwrite=TRUE)
print(gbif_citation(gbif_zip_download))
unzip(gbif_zip_download)
print("Downloading datasets from EarthEnv.../n")
print("Downloading datasets from EarthEnv.../n")
print("Downloading datasets from EarthEnv...\n")
for (i in 1:10){
print("Downloading datasets from EarthEnv...\n")
}
cat("Downloading datasets from EarthEnv...\n")
if ("EarthEnv" %in% databases_to_use ){
for (i in 1:10){
cat("Downloading datasets from EarthEnv...\n")
}
download.file("https://data.earthenv.org/streams/hydroclim_average+sum.nc",
paste(getwd(), "hydro_avg.nc", sep="/"), mode = "wb")
download.file("https://data.earthenv.org/streams/soil_maximum.nc",
paste(getwd(), "soil_max.nc", sep="/"), mode = "wb")
download.file("https://data.earthenv.org/streams/elevation.nc",
paste(getwd(), "elevation.nc", sep="/"), mode = "wb")
download.file("https://data.earthenv.org/streams/slope.nc",
paste(getwd(), "slope.nc", sep="/"), mode = "wb")
}
for (i in 1:10){
cat("Downloading datasets from EarthEnv...\n")
}
download.file("https://biogeo.ucdavis.edu/data/worldclim/v2.1/base/wc.1_10m_srad.zip", paste(getwd(), "srad_zip.zip", sep="/"), mode = "wb")
usethis::use_package("progress")
log(length(1000))
warnings()
log(1000)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
library(FishNmix2)
usethis::use_package("ncdf4")
library(FishNmix2)
library(FishNmix2)
dl_min_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_max_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_range_df <- data.frame(matrix(ncol = 3, nrow = 0))
resolution=30
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
minlat = -56maxlat = 60 , minlong =-145, maxlong = 180
minlat = -56
maxlat = 60
minlong =-145
maxlong = 180
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
ymin = -55.75
ymax =59.75
xmin  = -144.75
xmax = 179.75
step = 0.5
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
library(geosphere)
#loop that calculate min/max/range for each latitude
#/!\ takes a long time /!\
if (resolution == 30){
ymin = -55.75
ymax =59.75
xmin  = -144.75
xmax = 179.75
step = 0.5
for (y in seq(ymin,ymax,step)){
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max-min
for (x in seq(xmin,xmax,step)){
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
View(dl_max_df)
library(FishNmix2)
abiotics_df <- aggregate(earthenv_data[[1]], fact=2*resolution,fun=mean)
cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)
getDoParWorkers()
library(parallel)
library(doParallel)
cl <- makePSOCKcluster(detectCores()-2)
registerDoParallel(cl)
getDoParWorkers()
cat("EarthEnv  1/4...\n")
abiotics_df <- aggregate(earthenv_data[[1]], fact=2*resolution,fun=mean)
#create a list of index to use in the loop
months <-c("01","02","03","04","05","06","07","08","09","10","11","12")
bio <-c("12", "13", "14", "15")
#create empty raster brick with 12 layers, with nrow and ncol corresponding to 10 arcmins grid (before spatial filtering)
srad<-brick(nrows=1080,ncol=2160,nl=length(months))
library(raster'
)
)f
rf
$aeztvgtg'okÃ©k'
library(raster)
abiotics_df <- aggregate(earthenv_data[[1]], fact=2*resolution,fun=mean)
dl_min_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_max_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_range_df <- data.frame(matrix(ncol = 3, nrow = 0))
resolution = 30
if (resolution == 30) {
ymin = -10
ymax = 10
xmin = -10
xmax = 10
step = 1
for (y in seq(ymin, ymax, step)) {
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max - min
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
library(geosphere)
if (resolution == 30) {
ymin = -10
ymax = 10
xmin = -10
xmax = 10
step = 1
for (y in seq(ymin, ymax, step)) {
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max - min
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
View(dl_max_df)
if (resolution == 30) {
ymin = -10
ymax = 10
xmin = -10
xmax = 10
step = 0.5
for (y in seq(ymin, ymax, step)) {
min <- min(daylength(y, 1:365))
max <- max(daylength(y, 1:365))
range <- max - min
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
View(dl_max_df)
nb_x <- (xmax-xmin)/step
dl_min_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_max_df <- data.frame(matrix(ncol = 3, nrow = 0))
dl_range_df <- data.frame(matrix(ncol = 3, nrow = 0))
View(dl_max_df)
dl_min <- c(1,1,1)
rbind(dl_min_df, rep(dl_min, 5)
for (x in seq(xmin, xmax, step)) {
dl_min <- c(x, y, min)
dl_max <- c(x, y, max)
dl_range <- c(x, y, range)
dl_min_df <- rbind(dl_min_df, dl_min)
dl_max_df <- rbind(dl_max_df, dl_max)
dl_range_df <- rbind(dl_range_df, dl_range)
}
}
}
rbind(dl_min_df, rep(dl_min, 5))
View(dl_min_df)
rbind(dl_min_df, rep(dl_min, 5))
rep(dl_min, 5)
dl_min <- c(1,1,1)
rbind(dl_min_df, rep(dl_min, 5))
rep(dl_min, 5)
dl_min-vect <- rep(dl_min, 5)
dl_min_vect <- rep(dl_min, 5)
dupdf <- df[dl_min_vect,]
dl_min <- as.data.frame(x, y, min)
dl_min <- as.data.frame(dl_min)
View(dl_min)
dl_min_vect <- rep(dl_min, 5)
dl_min_names=c("x", "y", "min")
dl_min <- c(x, y, min)
dl_min_df <- data.frame(dl_min_names, dl_min)
View(dl_min_df)
dl_min_df <- data.frame(y, min)
View(dl_min_df)
dl_min_df[2]
dl_min_vect <- rep(dl_min_df[2], 5)
View(dl_min_vect)
dl_min_vect <- rep(dl_min_df[2,], 5)
View(dl_min_df)
test <- data.frame(x,y)
x <- c(1,1,1,2,2,2,3,3,3)
y <- c(10,10,10,11,11,11,12,12,12)
test <- data.frame(x,y)
View(test)
newtest <- merge(test, dl_min_df, by = c("x", "y"))
newtest <- merge(test, dl_min_df, by =  "y")
View(newtest)
